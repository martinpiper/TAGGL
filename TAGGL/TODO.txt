* Does kTAGFunctionAddTemplate need mNeedToSendSystemInits and cause "04 (F) = system startup        (when new system is started)" and "06 (F) = instance startup      (when system is started, or world template added)"
	To all objects, or only the one being added?



* Similarly does kTAGFunctionDeleteTemplate need "07 (F) = instance closedown    (when system is close, or world template deleted)" sent to every object, or just the one being deleted?



* // MPi: TODO: Implement properly
	Several operations are not handled properly here



* "Data\MIME" throws ARM handler exceptions: Template $143e0 Running Event Frame:10 for 'Trex            ' handler 1='MIME            '
	00047130 : e8aa0007 stmia r10!, {r0, r1, r2}
	Assertion failed!



* "Data\BHPOutput\Control" + "Data\BHPOutput\Game" + "Data\BHPOutput\Track2" needs: CallbackTAGFunction $8124
	&24- Object Transform (rotate then add wld x/y/z)



* "Data\BHPOutput\Control" needs:
	CallbackTAGFunction $8154
		Several types
	CallbackTAGFunction $8140
	CallbackTAGFunction $8128
		&28- Exec New System / Exec New App / Merge App Data
		Template $142b0 Running Event Frame:4 for 'Control         ' handler 0='CtrlApp         '
		r0	0xffffffff
		r1	0x00014930
	Adding kTAGFunctionExecNew
		Seeing: +		name	0x00cfebe0 "BHPdata:Titles"	char[0x00000011]




Could probably do with some fake sample headers to stop a handler exception at startup



// MPi: TODO: 04/15 = misc parameters (if added using add_world)



// MPi: TODO: I think this needs some template data words ARM memory setup



Look at merging BHP Track3 with Game. Load Game first then Track3?
Check the original applicaton, it might load control first, then check handlers.
	According to C:\Backups\OldMachines\OldMachineBackup\D\RPCEmu\hostfs\BHP\Output\!Run,feb
	Control is loaded on its own first




Systems and Worlds, they need compiled (loaded) and live data. They get reinitialised from the compiled data.
Every loaded resource need this allocated in the ARM memory:
00/03 = ptr to compiled resource data
04/07 = ptr to live resource data       
08/11 = internal use  (bounding box size if template resource)
12/15 = internal use  
16/31 = resource name (padded with spaces)
Don't worry about the vertex list updating for the MIME demo. Instead optimise for the general case which is static model verts.
The live system and world data needs to be split into functions so the live data can be quickly converted to the C++ form for each frame.
Basically if the pre-frame code handler is called then mark the world template as dirty as well as the system.
Then update data for those dirty objects from the live data.



Run the collision update and the event



Add TAG function 8118



Breakpoint on unimplemented TAG functions in CallbackTAGFunction.
Then implement.



Transparency. The problem with this is that is uses face flags. Not sprite mask data.






Move sTheARM into a new instance within ARMCore



If a handler generates an exception then warn once if debug is turned on and stop it from running in the future.
The exception will need to be passed back from ARMCore.



Check the object scale is fed through from the world template.



Also check the world template scale is copied over.



// MPi: TODO: Find the distance of the current matrix from the viewpoint and choose the object



Optimise the model draw to use compiled GL.
// MPi: TODO: Instead of verts per triangle use glGenLists, glNewList and GL_COMPILE for the base object
This is complicated by the fact that during execution the handlers can be modifying binary data in ARM memory.
The ARM CPU will need some hooks to allow the OpenGL code to register for interesting parts of memory and receive callbacks when certain locations are modified.
Then when these callbacks are received they can cause the ARM memory to be reparsed into the OpenGL lists.


// MPi: TODO: Produce a proper heap that can free blocks. At the moment this just increments.



// MPi: TODO: Implement proper TAG ARM internal data structures



// MPi: TODO: When the system is re-run then this needs to be copied from the loaded data
// MPi: TODO: When the world is re-run then this needs to be copied from the loaded data



// MPi: TODO: Need temp work area in R10



// MPi: TODO: The live world needs a proper linklist



// MPi: TODO: Fill in proper template live data like object and handler data



